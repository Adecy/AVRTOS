/* automatically generated by rust-bindgen 0.69.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type size_t = ::core::ffi::c_uint;
pub type k_ticks_t = u32;
pub type k_delta_t = k_ticks_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_timeout_t {
    pub value: k_ticks_t,
}
#[doc = " - a dnode is already in the list if next != null and prev != null\n - a dnode is not in the list if next == null && prev == null\n - poping the last element of the runqueue doesn't have no any effect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dnode {
    pub __bindgen_anon_1: dnode__bindgen_ty_1,
    pub __bindgen_anon_2: dnode__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dnode__bindgen_ty_1 {
    pub next: *mut dnode,
    pub head: *mut dnode,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dnode__bindgen_ty_2 {
    pub prev: *mut dnode,
    pub tail: *mut dnode,
}
extern "C" {
    #[doc = " @brief Initialize a doubly linked list\n\n @param list"]
    pub fn dlist_init(list: *mut dnode);
}
extern "C" {
    #[doc = " @brief Add (queue) a node to the end of a doubly linked list\n\n @param list\n @param node"]
    pub fn dlist_append(list: *mut dnode, node: *mut dnode);
}
extern "C" {
    #[doc = " @brief Add (queue) a node to the beginning of a doubly linked list\n\n @param list\n @param node"]
    pub fn dlist_prepend(list: *mut dnode, node: *mut dnode);
}
extern "C" {
    #[doc = " @brief Insert a node before a given node\n\n @param successor\n @param node"]
    pub fn dlist_insert(successor: *mut dnode, node: *mut dnode);
}
extern "C" {
    #[doc = " @brief Remove a node from a doubly linked list\n\n @param node"]
    pub fn dlist_remove(node: *mut dnode);
}
extern "C" {
    #[doc = " @brief Get the first node of a doubly linked list (dequeue)\n\n @param list\n @return struct dnode*"]
    pub fn dlist_get(list: *mut dnode) -> *mut dnode;
}
extern "C" {
    #[doc = " @brief Check if a doubly linked list is empty\n\n @param list\n @return true\n @return false"]
    pub fn dlist_is_empty(list: *mut dnode) -> bool;
}
extern "C" {
    #[doc = " @brief Calculate the number of items in a doubly linked list\n\n @param list\n @return uint8_t"]
    pub fn dlist_count(list: *mut dnode) -> u8;
}
#[doc = " @brief Scheduling queue data structure\n\n - n : number of items in the list\n\n tqueue_schedule/tqueue_pop are O(1)\n tqueue_remove is O(n)\n tqueue_shift is O(n)\n\n TODO tqueue_remove could be optimized to O(1), using a doubly linked list"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct titem {
    pub __bindgen_anon_1: titem__bindgen_ty_1,
    pub next: *mut titem,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union titem__bindgen_ty_1 {
    pub delay_shift: k_delta_t,
    pub abs_delay: k_delta_t,
    pub timeout: k_delta_t,
}
extern "C" {
    #[doc = " @brief Schedule an event by adding it to the list.\n If the new event has the same timeout as another event\n already in the list, it will be added after i.\n\n Assumptions :\n - root is not null\n - item is not null\n - item->next is null\n - item->timeout is set\n\n @param root\n @param item"]
    pub fn z_tqueue_schedule(root: *mut *mut titem, item: *mut titem);
}
extern "C" {
    #[doc = " @see z_tqueue_schedule\n\n Assumptions :\n  - root is not null\n\n @param root\n @param item\n @param timeout"]
    pub fn tqueue_schedule(root: *mut *mut titem, item: *mut titem, timeout: k_delta_t);
}
extern "C" {
    #[doc = " @brief Shift the queue time of {time_passed}\n\n Assumptions :\n  - root is not null\n\n @param root\n @param time_passed"]
    pub fn tqueue_shift(root: *mut *mut titem, time_passed: k_delta_t);
}
extern "C" {
    #[doc = " @brief Pop an item from the time queue.\n\n Note: this function doesn't alter/reset the item->tie nor the item->next members.\n\n Assumptions:\n - root is not null\n\n @param root\n @return struct titem*"]
    pub fn tqueue_pop(root: *mut *mut titem) -> *mut titem;
}
extern "C" {
    #[doc = " @brief\n\n @param root\n @return struct titem*"]
    pub fn tqueue_pop_reschedule(root: *mut *mut titem, timeout: k_delta_t) -> *mut titem;
}
extern "C" {
    #[doc = " @brief Remove an item from the time queue.\n Item->next attribute is set to null if found.\n\n Note: this function is very expensive in term of time if there are a\n  lot of items in the titem queue.\n\n Assumptions :\n  - root is not null\n  - item is not null\n  - item is in root tqueue\n\n @param root\n @param item Item to remove if exists in the time queue."]
    pub fn tqueue_remove(root: *mut *mut titem, item: *mut titem);
}
#[doc = " @brief Thread entry point function type.\n\n The `k_thread_entry_t` type is a function pointer type representing a thread\n entry point function. A thread entry point function is a function that serves\n as the starting point for the execution of a thread. It takes a single\n `void*` parameter used to pass the thread context when the entry function is\n called.\n\n @param context A pointer to the context data for the thread."]
pub type k_thread_entry_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[doc = " @brief Structure representing a thread.\n\n The `struct k_thread` structure represents a thread and defines various\n properties associated with it, including the stack pointer, thread priority,\n stack location and size, local storage pointer, and other relevant fields.\n\n This structure is 16 bytes long in its minimal form."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_thread {
    pub sp: *mut ::core::ffi::c_void,
    pub flags: u8,
    pub tie: k_thread__bindgen_ty_1,
    pub __bindgen_anon_1: k_thread__bindgen_ty_2,
    pub swap_data: *mut ::core::ffi::c_void,
    pub stack: k_thread__bindgen_ty_3,
    pub symbol: ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_thread__bindgen_ty_1 {
    pub runqueue: dnode,
    pub event: titem,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_thread__bindgen_ty_2 {
    pub wany: dnode,
    pub wmutex: dnode,
    pub wsem: dnode,
    pub wsig: dnode,
    pub wfifo: dnode,
    pub wmsgq: dnode,
    pub wflags: dnode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_thread__bindgen_ty_3 {
    pub end: *mut ::core::ffi::c_void,
    pub size: size_t,
}
#[doc = " @brief Structure representing the call-saved registers + PC (size=19 bytes)\n\n Read \"Call-used registers\" of the AVR GCC manual for more information:\n https://gcc.gnu.org/wiki/avr-gcc#Call-Saved_Registers"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_callsaved_ctx {
    pub sreg: u8,
    pub __bindgen_anon_1: z_callsaved_ctx__bindgen_ty_1,
    pub __bindgen_anon_2: z_callsaved_ctx__bindgen_ty_2,
    pub __bindgen_anon_3: z_callsaved_ctx__bindgen_ty_3,
    pub __bindgen_anon_4: z_callsaved_ctx__bindgen_ty_4,
    pub __bindgen_anon_5: z_callsaved_ctx__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union z_callsaved_ctx__bindgen_ty_1 {
    pub regs: [u8; 13usize],
    pub __bindgen_anon_1: z_callsaved_ctx__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_callsaved_ctx__bindgen_ty_1__bindgen_ty_1 {
    pub r29: u8,
    pub r28: u8,
    pub r17: u8,
    pub r16: u8,
    pub r15: u8,
    pub r14: u8,
    pub r13: u8,
    pub r12: u8,
    pub r11: u8,
    pub r10: u8,
    pub r9: u8,
    pub r8: u8,
    pub r7: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union z_callsaved_ctx__bindgen_ty_2 {
    pub r6: u8,
    pub init_sreg: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union z_callsaved_ctx__bindgen_ty_3 {
    pub __bindgen_anon_1: z_callsaved_ctx__bindgen_ty_3__bindgen_ty_1,
    pub thread_entry: k_thread_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_callsaved_ctx__bindgen_ty_3__bindgen_ty_1 {
    pub r5: u8,
    pub r4: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union z_callsaved_ctx__bindgen_ty_4 {
    pub __bindgen_anon_1: z_callsaved_ctx__bindgen_ty_4__bindgen_ty_1,
    pub thread_context: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_callsaved_ctx__bindgen_ty_4__bindgen_ty_1 {
    pub r3: u8,
    pub r2: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_callsaved_ctx__bindgen_ty_5 {
    pub pch: u8,
    pub pc: *mut ::core::ffi::c_void,
}
#[doc = " @brief Structure representing the call-used register of a function call.\n\n Read \"Call-used registers\" of the AVR GCC manual for more information:\n https://gcc.gnu.org/wiki/avr-gcc#Call-Used_Registers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_callused_ctx {
    pub r18: u8,
    pub r19: u8,
    pub r20: u8,
    pub r21: u8,
    pub r22: u8,
    pub r23: u8,
    pub r24: u8,
    pub r25: u8,
    pub r26: u8,
    pub r27: u8,
    pub r30: u8,
    pub r31: u8,
}
#[doc = " @brief Represent the registers to be saved during an interrupt before calling\n the ISR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_intctx {
    pub pch: u8,
    pub pc: *mut ::core::ffi::c_void,
    pub r1: u8,
    pub r0: u8,
    pub sreg: u8,
    pub callused_reg: z_callused_ctx,
}
extern "C" {
    #[doc = " @brief Perform a thread switch (assembly function).\n\n This function performs a context switch between two threads. The steps\n involved in the thread switch are as follows:\n\n 1. Save the context of the first thread.\n 2. Store the stack pointer (SP) of the first thread to its structure.\n 3. Restore the stack pointer (SP) of the second thread from its structure.\n 4. Restore the context of the second thread.\n\n @param from Pointer to the thread structure of the first thread.\n @param to Pointer to the thread structure of the second thread."]
    pub fn z_thread_switch(from: *mut k_thread, to: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Make the current thread waiting/pending for an object being available.\n\n Suspend the thread and add it to the waitqueue.\n The function will return if the thread is awakaned or on timeout.\n\n If timeout is K_FOREVER, the thread should we awakaned.\n If timeout is K_NO_WAIT, the thread returns immediately\n\n Assumptions :\n  - interrupt flag is cleared when called.\n\n @param waitqueue\n @param timeout\n @return 0 on success (object available), ETIMEDOUT on timeout, negative error\n  in other cases."]
    pub fn z_pend_current(waitqueue: *mut dnode, timeout: k_timeout_t) -> i8;
}
extern "C" {
    #[doc = " @brief Wake up the first thread pending on an object.\n Switch thread before returning.\n\n Assumptions :\n - interrupt flag is cleared when called\n - waitqueue is not null\n - Thread in the runqueue is suspended\n\n @param waitqueue\n @param swap_data : available object information\n @return uint8_t return 0 if a thread got the object, any other value\n otherwise"]
    pub fn z_unpend_first_thread(waitqueue: *mut dnode) -> *mut k_thread;
}
extern "C" {
    #[doc = " @brief Wake up the first thread pending on an object.\n Set the first pending thread swap_data parameter if set.\n Switch thread before returning.\n\n @see z_unpend_first_thread\n\n Assumptions :\n - interrupt flag is cleared when called\n - waitqueue is not null\n - Thread in the runqueue is suspended\n\n @param waitqueue\n @param set_swap_data\n @return thread pointer if a thread got the object, NULL otherwise"]
    pub fn z_unpend_first_and_swap(
        waitqueue: *mut dnode,
        set_swap_data: *mut ::core::ffi::c_void,
    ) -> *mut k_thread;
}
extern "C" {
    #[doc = " @brief Cancel the first pending thread on a waitqueue.\n\n Raise \"pend_canceled\" flag on the thread, any wait function will return\n with -ECANCELED.\n\n @param waitqueue"]
    pub fn z_cancel_first_pending(waitqueue: *mut dnode);
}
extern "C" {
    #[doc = " @brief Cancel all pending threads on a waitqueue.\n\n Raise \"pend_canceled\" flag on the thread, any wait function will return\n with -ECANCELED.\n\n @param waitqueue\n @return Number of canceled threads"]
    pub fn z_cancel_all_pending(waitqueue: *mut dnode) -> u8;
}
extern "C" {
    #[doc = " @brief Wake up a thread.\n\n Cancel scheduled wake up if any and add the thread to the runqueue.\n\n @param thread"]
    pub fn z_wake_up(thread: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Helper function\n\n @return true, interrupt flag is set\n @return false, interrupt flag is cleared"]
    pub fn z_interrupts() -> bool;
}
extern "C" {
    #[doc = " @brief Initialize stack sentinel byte(s) for all threads.\n"]
    pub fn z_init_stacks_sentinel();
}
extern "C" {
    #[doc = " @brief Initialize stack sentinel byte(s) for specified thread.\n\n @param thread"]
    pub fn z_init_thread_stack_sentinel(thread: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Verify if stack sentinel byte(s) is(are) still intact for given thread.\n\n @param thread The thread to verify\n @return true\n @return false"]
    pub fn z_thread_verify_sent(thread: *mut k_thread) -> bool;
}
extern "C" {
    #[doc = " @brief Assert evaluated expression is not zero\n\n @param expression Expression to evaluate\n @param module Module whithin the assertion is made (K_MODULE_*)\n @param acode Assertion code (K_ASSERT_*)\n @param line Line number of the assertion within the source file"]
    pub fn __assert(expression: u8, module: u8, acode: u8, line: u16);
}
extern "C" {
    #[doc = " @brief Define a new thread at runtime and initialize its stack\n\n @param thread hread structure pointer\n @param entry thread entry function\n @param stack thread stack start location\n @param stack_size thread stack size\n @param priority thread priority\n @param context_p thread context passed to entry function\n @param symbol thread symbol letter\n @return int8_t 0 on success"]
    pub fn k_thread_create(
        thread: *mut k_thread,
        entry: k_thread_entry_t,
        stack: *mut ::core::ffi::c_void,
        stack_size: size_t,
        priority: u8,
        context_p: *mut ::core::ffi::c_void,
        symbol: ::core::ffi::c_char,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Start the execution of the given thread.\n\n @param thread The thread to start execution.\n @return 0 if successful, otherwise a negative error code."]
    pub fn k_thread_start(thread: *mut k_thread) -> i8;
}
extern "C" {
    #[doc = " @brief Stop the execution of the specified thread.\n\n @param thread The thread to stop execution.\n @return 0 if successful, otherwise a negative error code."]
    pub fn k_thread_stop(thread: *mut k_thread) -> i8;
}
extern "C" {
    #[doc = " @brief Stop the execution of the current thread.\n\n @see k_thread_stop\n\n @param thread The ready/pending thread to start."]
    pub fn k_stop();
}
extern "C" {
    #[doc = " @brief Set the priority of the specified thread.\n\n This function allows you to change the priority of a given thread. The prio\n parameter can be set to either K_COOPERATIVE or K_PREEMPTIVE.\n\n @param thread The thread for which to change the priority.\n @param prio The desired priority (K_COOPERATIVE or K_PREEMPTIVE).\n @return The status code indicating the success or failure of the operation."]
    pub fn k_thread_set_priority(thread: *mut k_thread, prio: u8);
}
extern "C" {
    #[doc = " @brief Thread entry point function.\n\n This function serves as the entry point for a new thread. It is responsible\n for executing the code within the thread and receives a context pointer as an\n argument.\n\n @param context A pointer to the context data for the thread."]
    pub fn z_thread_entry(context: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Lock the scheduler for the current thread.\n\n This function sets the current thread as a cooperative thread until the\n function k_sched_unlock is called. The scheduler continues to execute system\n tasks and handle timeout. However, for cooperative threads, it is recommended\n that the execution time is kept short to avoid delaying other threads and\n potentially impacting time-sensitivethreads.\n\n Locking and unlocking the scheduler has no effect on cooperative threads.\n\n This function cannot be called from an interrupt routine.\n\n If CONFIG_KERNEL_REENTRANCY is defined, k_sched_unlock() can be\n called recursively. In this case, the maximum number of calls to k_sched_lock\n without calling k_sched_unlock() is 255.\n\n Note: Locking the scheduler doesn't have an impact on functions that\n explicitely yields the CPU, such as k_yield(), k_sleep(), or any kernel\n function waiting for an event to be signaled (e.g., k_sem_take(),\n k_mutex_lock() with delay), is called."]
    pub fn k_sched_lock();
}
extern "C" {
    #[doc = " @brief Unlock the scheduler for the current thread and set it as preemptive.\n\n This function unlocks the scheduler for the current thread, allowing it to be\n preempted by other threads.\n\n For cooperative threads, locking and unlocking the scheduler has no effect.\n\n This function cannot be called from an interrupt routine.\n\n @see k_sched_lock()"]
    pub fn k_sched_unlock();
}
extern "C" {
    #[doc = " @brief Check if the scheduler is locked by the current thread.\n\n This function determines whether the scheduler is locked by the current\n thread or if the thread is a cooperative thread.\n\n @see k_sched_lock()\n @see k_sched_unlock()\n\n @return true if the scheduler is locked for the current thread or if the\n thread is cooperative.\n @return false otherwise."]
    pub fn k_sched_locked() -> bool;
}
extern "C" {
    #[doc = " @brief Check if the current thread is preemptive.\n\n This function determines whether the current thread is preemptive.\n\n @return true if the current thread is preemptive."]
    pub fn k_cur_is_preempt() -> bool;
}
extern "C" {
    #[doc = " @brief Check if the current thread is cooperative.\n\n This function determines whether the current thread is cooperative.\n\n @return true if the current thread is cooperative."]
    pub fn k_cur_is_coop() -> bool;
}
extern "C" {
    #[doc = " @brief Suspend the execution of the current thread for the specified amount\n of time.\n\n This function schedules the current thread to be woken up after the specified\n amount of time.\n\n If the timeout is set to K_FOREVER, the thread will not be executed again\n until explicitly resumed with z_wake_up() or z_schedule().\n\n If the timeout is set to K_NO_WAIT, the function has no effect.\n\n @see k_yield\n\n @param timeout The duration of the sleep in milliseconds."]
    pub fn k_sleep(timeout: k_timeout_t);
}
extern "C" {
    #[doc = " @brief Make the thread wait for the specified amount of time in milliseconds,\n but keep it ready (in opposite to k_sleep which suspends the thread).\n\n The function must poll the elapsed time and is in charge to exit to continu\n the execution of the current thread.\n\n This function doesn't disable interrupts and doesn't break system time.\n However the choosen mode can affect the execution of other threads.\n\n Note: This function can always be used without an IDLE thread (with\n CONFIG_KERNEL_THREAD_IDLE disabled).\n\n Note: Requires KERNEL_UPTIME to be enabled.\n\n @param timeout The duration to wait in milliseconds.\n @param mode The wait mode (K_WAIT_MODE_IDLE, K_WAIT_MODE_ACTIVE,\n K_WAIT_MODE_BLOCK)"]
    pub fn k_wait(delay: k_timeout_t, mode: u8);
}
extern "C" {
    #[doc = " @brief Block the RTOS (scheduler + SYSCLOCK) for the specified amount of time\n in microseconds.\n\n Note: consider using this function only for very short delays.\n Do not exceed CONFIG_KERNEL_SYSCLOCK_PERIOD_US (converted to milliseconds),\n otherwise the system uptime may be delayed.\n\n This function relies on _delay_us() from <util/delay.h> which can only be\n used in release mode(not in debug mode).\n\n @param delay_us The duration to block in microseconds."]
    pub fn z_cpu_block_us(delay_us: u32);
}
extern "C" {
    #[doc = " @brief Block the RTOS (scheduler + SYSCLOCK) for the specified amount of time\n in milliseconds.\n\n Note: consider using this function only for very short delays.\n Do not exceed CONFIG_KERNEL_SYSCLOCK_PERIOD_US (converted to milliseconds),\n otherwise the system uptime may be delayed.\n\n This function relies on _delay_ms() from <util/delay.h> which can only be\n used in release mode(not in debug mode).\n\n @param delay_ms The duration to block in milliseconds."]
    pub fn z_cpu_block_ms(delay_ms: u32);
}
extern "C" {
    #[doc = " @brief Get the number of currently ready threads.\n\n This function returns the count of threads that are currently in the ready\n state, meaning they are eligible for execution. If the CPU is in the IDLE\n state with no threads ready for execution, the function will return 0.\n\n @return The number of currently ready threads."]
    pub fn k_ready_count() -> u8;
}
extern "C" {
    #[doc = " @brief Yield the CPU to another ready thread, assuming interrupts are\n disabled.\n\n The behavior is similar to k_yield(), but with the additional assumption that\n interrupts are already disabled.\n\n @see k_yield"]
    pub fn z_yield();
}
extern "C" {
    #[doc = " @brief Assertion helper to check if the code is running in user context.\n\n This function is an assertion helper that checks if the code is executing in\n user context. It can be used to verify that certain operations or code paths\n are only accessed in user context. If the code is not running in user\n context, an assertion failure or error can be triggered."]
    pub fn z_assert_user_context();
}
extern "C" {
    #[doc = " @brief Assertion helper to check if a thread is in the ready state.\n\n This function is an assertion helper that checks if a given thread is in the\n ready state, indicating that it is eligible for execution.\n\n If the thread is not in the ready state, an assertion failure or error can be\n triggered.\n\n @param thread The thread to check."]
    pub fn z_assert_thread_ready(thread: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Get uptime in ticks (32 bit), if KERNEL_TICKS is enabled\n\n @return Kernel ticks value (32 bits)"]
    pub fn k_ticks_get_32() -> u32;
}
extern "C" {
    #[doc = " @brief Get uptime in ticks (64 bits), if KERNEL_TICKS is enabled.\n Meaningful only if CONFIG_CONFIG_KERNEL_TICKS_COUNTER_40BITS is enabled,\n otherwise, this function is equivalent to k_ticks_get_32.\n\n @return Kernel ticks value (64 bits)"]
    pub fn k_ticks_get_64() -> u64;
}
extern "C" {
    #[doc = " @brief Get uptime in milliseconds, if KERNEL_UPTIME is enabled\n\n @return Uptime in milliseconds"]
    pub fn k_uptime_get_ms32() -> u32;
}
extern "C" {
    #[doc = " @brief Get uptime in milliseconds, if KERNEL_UPTIME is enabled.\n\n Should be used if KERNEL_UPTIME_40BITS is enabled.\n\n @return Uptime in milliseconds (64 bits)"]
    pub fn k_uptime_get_ms64() -> u64;
}
extern "C" {
    #[doc = " @brief Get uptime in seconds, if KERNEL_UPTIME is enabled\n\n @return Uptime in seconds"]
    pub fn k_uptime_get() -> u32;
}
extern "C" {
    #[doc = " @brief Manual user AVRTOS init"]
    pub fn z_avrtos_init();
}
#[doc = " @brief Optimized queue data structure with head/tail entries.\n\n queue/dequeue actions are O(1)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct snode {
    pub next: *mut snode,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slist {
    pub head: *mut snode,
    pub tail: *mut snode,
}
extern "C" {
    pub fn slist_init(list: *mut slist);
}
extern "C" {
    pub fn slist_append(list: *mut slist, node: *mut snode);
}
extern "C" {
    pub fn slist_get(list: *mut slist) -> *mut snode;
}
extern "C" {
    #[doc = " @brief Initialize the USART with custom baudrate\n\n @param baud Baudrate"]
    pub fn serial_init_baud(baud: u32);
}
extern "C" {
    #[doc = " @brief Print the AVRTOS banner over the USART"]
    pub fn serial_print_banner();
}
extern "C" {
    #[doc = " @brief Send a single character over the USART\n\n @param data"]
    pub fn serial_transmit(data: ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Send the buffer of known length over the USART\n\n @param buffer\n @param len"]
    pub fn serial_send(buffer: *const ::core::ffi::c_char, len: size_t);
}
extern "C" {
    #[doc = " @brief Send the string over the USART, length is auto-calculated\n\n @param text"]
    pub fn serial_print(text: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Send the string over the USART with line return \"\\n\", length is\n auto-calculated\n\n @param text"]
    pub fn serial_printl(text: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Print an unsigned uint8_t in base 10 over the USART\n\n @param val"]
    pub fn serial_u8(val: u8);
}
extern "C" {
    #[doc = " @brief Print a signed int8_t in base 10 over the USART\n\n @param val"]
    pub fn serial_s8(val: i8);
}
extern "C" {
    #[doc = " @brief Print an unsigned uint16_t in base 10 over the USART\n\n @param val"]
    pub fn serial_u16(val: u16);
}
extern "C" {
    #[doc = " @brief Print an unsigned uint8_t in base 16 over the USART\n\n @param val"]
    pub fn serial_hex(val: u8);
}
extern "C" {
    #[doc = " @brief Print an unsigned uint16_t in base 16 over the USART\n\n @param val"]
    pub fn serial_hex16(val: u16);
}
extern "C" {
    #[doc = " @brief Print a buffer of uint8_t in base 16 over the USART\n\n @param val"]
    pub fn serial_send_hex(buffer: *const u8, len: size_t);
}
extern "C" {
    #[doc = " @brief Send the buffer stored in PROGMEM of known length over the USART\n\n @param buffer\n @param len"]
    pub fn serial_send_p(buffer: *const ::core::ffi::c_char, len: size_t);
}
extern "C" {
    #[doc = " @brief Send the string stored in PROGMEM over the USART, length is\n auto-calculated\n\n @param text"]
    pub fn serial_print_p(text: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Send the string stored in PROGMEM over the USART with line return\n \"\\n\", length is auto-calculated\n\n @param text"]
    pub fn serial_printl_p(text: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn print_slist(
        list: *mut slist,
        qitem_printer: ::core::option::Option<unsafe extern "C" fn(item: *mut snode)>,
    );
}
extern "C" {
    pub fn print_dlist(
        dlist: *mut dnode,
        ditem_printer: ::core::option::Option<unsafe extern "C" fn(item: *mut dnode)>,
    );
}
extern "C" {
    pub fn print_tqueue(
        root: *mut titem,
        titem_printer: ::core::option::Option<unsafe extern "C" fn(item: *mut titem)>,
    );
}
pub type atomic_val_t = u8;
pub type atomic_t = u8;
extern "C" {
    #[doc = " @brief Get the current value of an atomic variable.\n\n Note: This function is equivalent to directly read the 1 byte address\n\n @param target\n @return Value of the atomic variable."]
    pub fn atomic_get(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Set the value of an atomic variable.\n\n Note: This function is equivalent to directly write the 1 byte address\n\n @param target\n @return Old value of the atomic variable."]
    pub fn atomic_set(target: *mut atomic_t, value: u32) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Clear the value of an atomic variable but do not return the old value.\n\n @param target"]
    pub fn atomic_blind_clear(target: *mut atomic_t);
}
extern "C" {
    #[doc = " @brief Clear the value of an atomic variable.\n\n @param target\n @return Return the old value."]
    pub fn atomic_clear(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Calculate the OR of value and the atomic variable,\n  and store the result in the atomic variable.\n\n @param target\n @param value\n @return Return the old value."]
    pub fn atomic_or(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Calculate the XOR of value and the atomic variable,\n  and store the result in the atomic variable.\n\n @param target\n @param value\n @return Return the old value."]
    pub fn atomic_xor(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Calculate the AND of value and the atomic variable,\n  and store the result in the atomic variable.\n\n @param target\n @param value\n @return Return the old value."]
    pub fn atomic_and(target: *mut atomic_t, value: atomic_val_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Increment the atomic variable by one.\n  Return the current value.\n\n Note: return value is not the old value.\n\n @param target\n @return Return the new value."]
    pub fn atomic_inc(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Decrement the atomic variable by one.\n  Return the current value.\n\n Note: return value is not the old value.\n\n @param target\n @return Return the new value."]
    pub fn atomic_dec(target: *mut atomic_t) -> atomic_val_t;
}
extern "C" {
    #[doc = " @brief Clear the bit at position @p bit in the atomic variable.\n\n @param target\n @param bit"]
    pub fn atomic_clear_bit(target: *mut atomic_t, bit: u8);
}
extern "C" {
    #[doc = " @brief Set the bit at position @p bit in the atomic variable.\n\n @param target\n @param bit"]
    pub fn atomic_set_bit(target: *mut atomic_t, bit: u8);
}
extern "C" {
    #[doc = " @brief Set the bit at position @p bit to value @p val in the atomic variable.\n\n @param target\n @param bit\n @param val"]
    pub fn atomic_set_bit_to(target: *mut atomic_t, bit: u8, val: bool);
}
extern "C" {
    #[doc = " @brief Test the bit at position @p bit in the atomic variable.\n\n @param target\n @param bit\n @return Return true if the bit is set, false otherwise."]
    pub fn atomic_test_bit(target: *mut atomic_t, bit: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Test the bit at position @p bit in the atomic variable and clear it.\n\n @param target\n @param bit\n @return Return true if the bit was set, false otherwise."]
    pub fn atomic_test_and_clear_bit(target: *mut atomic_t, bit: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Test the bit at position @p bit in the atomic variable and set it.\n\n @param target\n @param bit\n @return Return true if the bit was set, false otherwise."]
    pub fn atomic_test_and_set_bit(target: *mut atomic_t, bit: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Compare and set, Compare the atomic variable value with @p cmd value\n \t- If equal update the atomic variable value with @p val value\n \t- Left the atomic variable value unchanged if not equal\n\n @param target\n @param value\n @return Return true if the atomic variable value was updated, false\n otherwise."]
    pub fn atomic_cas(target: *mut atomic_t, cmd: atomic_val_t, val: atomic_val_t) -> bool;
}
extern "C" {
    #[doc = " @brief see atomic_cas\n\n @param target\n @param cmd\n @param val\n @return Return true if the atomic variable value was updated, false\n otherwise."]
    pub fn atomic_cas2(target: *mut atomic_t, cmd: atomic_val_t, val: atomic_val_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_ring {
    pub buffer: *mut u8,
    pub r: u8,
    pub w: u8,
    pub size: u8,
}
extern "C" {
    #[doc = " @brief Initialize a ring buffer\n\n @param ring\n @param buffer\n @param size\n @return int8_t"]
    pub fn k_ring_init(ring: *mut k_ring, buffer: *mut u8, size: u8) -> i8;
}
extern "C" {
    pub fn k_ring_push(ring: *mut k_ring, data: ::core::ffi::c_char) -> i8;
}
extern "C" {
    pub fn k_ring_pop(ring: *mut k_ring, data: *mut ::core::ffi::c_char) -> i8;
}
extern "C" {
    pub fn k_ring_reset(ring: *mut k_ring) -> i8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_flags {
    pub _waitqueue: dnode,
    pub flags: u8,
    pub reset_value: u8,
}
pub mod k_flags_options_t {
    pub type Type = ::core::ffi::c_uint;
    pub const K_FLAGS_SET_ANY: Type = 1;
    pub const K_FLAGS_SET_ALL: Type = 4;
    pub const K_FLAGS_CLR_ALL: Type = 4;
    pub const K_FLAGS_CLR_ANY: Type = 8;
    pub const K_FLAGS_CONSUME: Type = 16;
    pub const K_FLAGS_SET: Type = 32;
    pub const K_FLAGS_CLR: Type = 64;
    pub const K_FLAGS_SCHED: Type = 128;
}
extern "C" {
    #[doc = " @brief Initialize a flags object\n\n @param flags Flags object\n @param value Initial value\n @return int"]
    pub fn k_flags_init(flags: *mut k_flags, value: u8) -> i8;
}
extern "C" {
    #[doc = " @brief Poll for any bit of the flags to be set\n\n @param flags Flags object\n @param mask Mask of bits to wait for\n @param options Options\n \t\tK_FLAGS_SET_ANY (required): Wait for any bit of the flags to be\n set K_FLAGS_CONSUME: Consume the flags after notification\n @param timeout Timeout to wait for if flags are not set\n @return int positive value on success: Mask of bits that made the thread wake\n up\n @return  -EINVAL if flags is NULL\n @return  -ENOTSUP if options is not supported\n @return  -EAGAIN if timeout is reached"]
    pub fn k_flags_poll(
        flags: *mut k_flags,
        mask: u8,
        options: k_flags_options_t::Type,
        timeout: k_timeout_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Notify a flags object\n\n @param flags Flags object\n @param mask Mask of bits to notify\n @param options Options\n \t\tK_FLAGS_SET (required): Set the flags\n \t\tK_FLAGS_SCHED: Call the scheduler if task have been wake up\n after notify()\n\n Note: K_FLAGS_SCHED SHOULD NOT be used in ISR context. Use return value to\n check if a task have been wake up. Call k_yield_from_isr_cond() if return\n value is strictly positive.\n\n @return int Number of tasks that have been wake up, negative value on error\n @return  -EINVAL if flags object is NULL\n @return  -ENOTSUP if options is not supported"]
    pub fn k_flags_notify(
        flags: *mut k_flags,
        notify_value: u8,
        options: k_flags_options_t::Type,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Reset a flags object\n\n Cancel all pending waiters and reset the flags to the initial value\n\n @param flags\n @return int"]
    pub fn k_flags_reset(flags: *mut k_flags) -> i8;
}
extern "C" {
    pub fn __fault(reason: u8);
}
extern "C" {
    #[doc = " @brief Tells whether the runqueue contains the thread IDLE\n\n @return true\n @return false"]
    pub fn k_is_cpu_idle() -> bool;
}
extern "C" {
    #[doc = " @brief IDLE the CPU.\n\n This function can be called from any thread to make it behave as an IDLE\n thread.\n\n This function shouldn't be called from an ISR.\n\n If others thread a ready, the function will call k_yield() to give them\n a chance to run. If no other thread is ready, the MCU is put in sleep mode\n until an interrupt occurs.\n\n The function keeps the thread as \"ready\". This means that if an interrupt\n occurs or other threads finished to consume their time slice,\n the thread will be scheduled to run again.\n\n Note: This function requires interrupts to be enabled."]
    pub fn k_idle();
}
extern "C" {
    #[doc = " @brief Initialize canaries in thread stack.\n\n @param thread"]
    pub fn z_init_thread_stack_canaries(thread: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Automatically initialize thread canaries in stack\n if configuration option CONFIG_THREAD_CANARIES is enabled.\n\n Stack is filled with symbol CONFIG_THREAD_CANARIES_SYMBOL\n\n Default THREAD_CANARIES_SYMBOl = 0xAA = 0b10101010"]
    pub fn z_init_stacks_canaries();
}
extern "C" {
    #[doc = " @brief Get the address of the furthest stack location used by the thread.\n i.e. We loop until we found canaries for the thread {thread}.\n\n @param thread\n @return void* Address of byte following the last found canary.\n (Address of the furthest stack location used by the thread.)"]
    pub fn z_stack_canaries(thread: *mut k_thread) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Pretty print found canaries in thread {thread}\n\n @param thread thread to check"]
    pub fn k_print_stack_canaries(thread: *mut k_thread);
}
extern "C" {
    #[doc = " @brief Pretty print found canaries in the current thread\n\n [M] CANARIES until @07CE [found 468], MAX usage = 44 / 512"]
    pub fn k_print_current_canaries();
}
extern "C" {
    #[doc = " @brief Pretty print found canaries in all threads\n\n [M] CANARIES until @07CE [found 468], MAX usage = 44 / 512\n [2] CANARIES until @010B [found 6], MAX usage = 506 / 512\n [1] CANARIES until @03C7 [found 194], MAX usage = 62 / 256\n [L] CANARIES until @04DE [found 217], MAX usage = 39 / 256\n [K] CANARIES until @051F [found 26], MAX usage = 36 / 62\n"]
    pub fn k_dump_stack_canaries();
}
extern "C" {
    #[doc = " @brief Verify if stack sentinel byte(s) is(are) still intact.\n\n @param thread\n @return true\n @return false"]
    pub fn k_verify_stack_sentinel(thread: *mut k_thread) -> bool;
}
extern "C" {
    #[doc = " @brief Check all registered stack sentinel bytes and fault on error.\n\n @param thread\n @return true\n @return false"]
    pub fn k_assert_registered_stack_sentinel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_prng {
    pub lfsr32: u32,
    pub lfsr31: u32,
}
extern "C" {
    pub fn k_prng_get(prng: *mut k_prng) -> u16;
}
extern "C" {
    pub fn k_prng_get_u32(prng: *mut k_prng) -> u32;
}
extern "C" {
    pub fn k_prng_get_buffer(prng: *mut k_prng, buffer: *mut u8, len: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: u32,
    pub tv_msec: u16,
}
extern "C" {
    #[doc = " @brief Get the current time.\n\n @param ts\n @return __kernel"]
    pub fn k_timespec_get(ts: *mut timespec);
}
extern "C" {
    #[doc = " @brief Set the current time.\n\n @param ts\n @return __kernel"]
    pub fn k_time_set(sec: u32);
}
extern "C" {
    #[doc = " @brief Check if the time is set.\n\n @return __kernel"]
    pub fn k_time_is_set() -> bool;
}
extern "C" {
    #[doc = " @brief Get the current time in seconds.\n\n @return __kernel"]
    pub fn k_time_get() -> u32;
}
extern "C" {
    #[doc = " @brief Get the current time in milliseconds.\n\n IF CONFIG_KERNEL_TIME_API_MS_PRECISION is set to 0, the return value is\n truncated to seconds.\n\n @return __kernel"]
    pub fn k_time_get_ms() -> u64;
}
extern "C" {
    #[doc = " @brief Unset the current time.\n\n @return __kernel"]
    pub fn k_time_unset();
}
extern "C" {
    #[doc = " @brief Print to serial the current uptime in seconds.\n\n @return __kernel"]
    pub fn k_show_uptime();
}
extern "C" {
    #[doc = " @brief Print to serial the current uptime in ticks.\n\n @return __kernel"]
    pub fn k_show_ticks();
}
#[doc = " @brief Event handler function.\n\n @warning Never call any k_yield(), k_yield_from_isr(),\n k_yield_from_isr_cond() from a timer handler.\n\n @param event Event that triggered the handler."]
pub type k_event_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut k_event)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_event {
    pub tie: titem,
    pub handler: k_event_handler_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl k_event {
    #[inline]
    pub fn scheduled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scheduled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(scheduled: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scheduled: u8 = unsafe { ::core::mem::transmute(scheduled) };
            scheduled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Initialize an event.\n\n @param event\n @param handler\n @return int"]
    pub fn k_event_init(event: *mut k_event, handler: k_event_handler_t) -> i8;
}
extern "C" {
    #[doc = " @brief Schedule the event to be triggered after timeout (in ms).\n\n Can be called from an interrupt.\n\n @param event\n @param timeout\n @return int"]
    pub fn k_event_schedule(event: *mut k_event, timeout: k_timeout_t) -> i8;
}
extern "C" {
    #[doc = " @brief Unschedule the event.\n\n Can be called from an interrupt.\n\n @param event\n @return int8_t Return 0 if the event was pending, -EAGAIN otherwise."]
    pub fn k_event_cancel(event: *mut k_event) -> i8;
}
extern "C" {
    #[doc = " @brief Unschedule the event.\n\n Can be called from an interrupt.\n\n @param event\n @return int"]
    pub fn k_event_pending(event: *mut k_event) -> bool;
}
extern "C" {
    #[doc = " @brief Internal function shifting the event queue and executing the handlers\n for the events that have expired.\n\n The call periodicity is constant and equals CONFIG_KERNEL_TIME_SLICE_US."]
    pub fn z_event_q_process();
}
#[doc = " @brief Structure representing a fifo.\n\n Queue lists all items added to the fifo in order.\n\n Waitqueue list contains all threads pending for a fifo item."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_fifo {
    pub queue: slist,
    pub waitqueue: dnode,
}
extern "C" {
    #[doc = " @brief Initialize a fifo if it wasn't defined using the macro K_FIFO_DEFINE.\n\n @param fifo"]
    pub fn k_fifo_init(fifo: *mut k_fifo) -> i8;
}
extern "C" {
    #[doc = " @brief Add an item to the fifo.\n\n Wake up the first thread pending on a fifo item.\n\n Can be called from an interrupt routine.\n\n IMPORTANT : first two bytes of the memory space {item_tie} are reserved\n for internal usage and cannot be use to store data.\n\n Note :\n Actually it's not the item itself which is added to the fifo but its \"tie\"\n member `item_tie` (first 2 bytes). As for workqueue we're using the\n CONTAINER_OF paragigm. For each item added to the fifo, you must define a\n structure containing this \"tie\" and the actual item data. See example\n \"fifo-slab\" or \"interrupt-yield\".\n\n Reference design :\n\n struct\n {\n  struct snode tie;\n  uint8_t value;\n } block1;\n block1.value = 17u;\n k_fifo_put(&myfifo, &block1);\n\n Note : in Zephyr RTOS project, there are two functions :\n - k_fifo_put : which needs the first word of the data to be reserved\n  -\n https://github.com/zephyrproject-rtos/zephyr/blob/main/include/kernel.h#L2074-L2088\n\n - k_fifo_alloc_put : which implicitely allocate this internal \"tie\" member.\n  -\n https://github.com/zephyrproject-rtos/zephyr/blob/main/include/kernel.h#L2095-L2111\n\n @param fifo pointer to the fifo\n @param item_tie pointer to the \"tie\" member of the item to add\n @return Thread that was woken up or NULL if no thread was pending"]
    pub fn k_fifo_put(fifo: *mut k_fifo, item_tie: *mut snode) -> *mut k_thread;
}
extern "C" {
    #[doc = " @brief @see k_fifo_put\n\n Assume interrupts are disabled\n\n @param fifo\n @param item\n @return Thread that was woken up or NULL if no thread was pending"]
    pub fn z_fifo_put(fifo: *mut k_fifo, item: *mut snode) -> *mut k_thread;
}
extern "C" {
    #[doc = " @brief Get and remove an item from the fifo.\n\n If there is no item in the fifo and timeout is different from K_NO_WAIT,\n the function is blocking until a item is added or timeout.\n\n Cannot be called from an interrupt routine\n if timeout is different from K_NO_WAIT.\n\n @param fifo\n @param timeout\n @return struct* not null if success"]
    pub fn k_fifo_get(fifo: *mut k_fifo, timeout: k_timeout_t) -> *mut snode;
}
extern "C" {
    #[doc = " @brief Cancel pending on a fifo queue.\n This routine causes first thread pending on fifo, if any,\n to return from k_fifo_get() call with NULL value (as if timeout expired).\n\n @param fifo\n @return Number of threads woken up"]
    pub fn k_fifo_cancel_wait(fifo: *mut k_fifo) -> u8;
}
extern "C" {
    #[doc = " @brief Tells if the fifo is empty.\n\n @param fifo\n @return True if empty, false otherwise"]
    pub fn k_fifo_is_empty(fifo: *mut k_fifo) -> bool;
}
extern "C" {
    #[doc = " @brief Get without removing the first item in the fifo.\n\n @param fifo\n @return struct* head item, NULL if empty"]
    pub fn k_fifo_peek_head(fifo: *mut k_fifo) -> *mut snode;
}
extern "C" {
    #[doc = " @brief Get without removing the last item in the fifo.\n\n @param fifo\n @return  struct* tail item, NULL if empty"]
    pub fn k_fifo_peek_tail(fifo: *mut k_fifo) -> *mut snode;
}
pub type k_work_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut k_work)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct k_work {
    pub _tie: snode,
    pub handler: k_work_handler_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_workqueue {
    pub q: k_fifo,
    pub flags: u8,
}
extern "C" {
    pub fn z_workqueue_entry(workqueue: *mut k_workqueue);
}
extern "C" {
    #[doc = " @brief Create a workqueue thread at runtime.\n\n @param workqueue workqueue struct\n @param thread thread struct\n @param stack stack buffer\n @param stack_size stack size\n @param prio_flags thread priority and flags\n @param symbol thread symbol\n @return __kernel 0 if success, negative error code otherwise"]
    pub fn k_workqueue_create(
        workqueue: *mut k_workqueue,
        thread: *mut k_thread,
        stack: *mut u8,
        stack_size: size_t,
        prio_flags: u8,
        symbol: ::core::ffi::c_char,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Initialize a workqueue item at runtime.\n k_work items can also be defined at compilation time using K_WORK_DEFINE\n\n @param work work item\n @param handler handler"]
    pub fn k_work_init(work: *mut k_work, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Submit a work item to the desired workqueue.\n\n If the work item has already been queued but didn't get processed, the\n work is not sent a new time.\n\n A work item started being processed can be submitted again.\n\n A work item can be sent from an interrupt handler.\n With \"signals\", this is the recommanded way to handle interrupts.\n\n Assumptions :\n  - workqueue is not null\n  - work is not null\n  - work->handler is not null\n\n @param workqueue\n @param work"]
    pub fn k_work_submit(workqueue: *mut k_workqueue, work: *mut k_work) -> bool;
}
extern "C" {
    #[doc = " @brief Configure the workqueue to release the cpu after each work item\n being processed.\n\n Prevent cooperative thread workqueue from keeping the cpu for too long\n if a lot of work items need to be processed.\n\n @param workqueue"]
    pub fn k_workqueue_enable_yieldeach(workqueue: *mut k_workqueue);
}
extern "C" {
    #[doc = " @brief Configure the workqueue to not release the cpu after each work\n item if there are more to be processed.\n\n Assumptions :\n  - work is not null\n  - work->handler is not null\n\n @see Undo k_workqueue_enable_yieldeach\n\n @param workqueue"]
    pub fn k_workqueue_disable_yieldeach(workqueue: *mut k_workqueue);
}
extern "C" {
    #[doc = " @brief Send a work item to the system workqueue\n\n @param work"]
    pub fn k_system_workqueue_submit(work: *mut k_work) -> bool;
}
#[doc = " @brief Delayable workqueue item.\n - Underlying work item to queue after timeout\n - Event object triggering the work item\n - Workqueue to queue the work item"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_work_delayable {
    pub work: k_work,
    pub _event: k_event,
    pub _workqueue: *mut k_workqueue,
}
extern "C" {
    #[doc = " Internal function triggered by the event object associated with the delayable work\n item,\n\n It must be declared extern to allow the k_work_delayable object to be defined\n statically."]
    pub fn z_delayable_work_trigger(event: *mut k_event);
}
extern "C" {
    #[doc = " @brief Initialize a delayable workqueue item at runtime.\n k_work_delayable items can also be defined at compilation time using\n K_WORK_DELAYABLE_DEFINE\n\n @param work work item\n @param handler handler"]
    pub fn k_work_delayable_init(dwork: *mut k_work_delayable, handler: k_work_handler_t);
}
extern "C" {
    #[doc = " @brief Schedule a delayable work item to be queued after the given timeout.\n\n If the work item has already been scheduled or queued for processing, the\n work is not sent a new time and the function returns -EAGAIN.\n\n @param workqueue Workqueue to queue the work item\n @param dwork Delayable work item\n @param timeout Timeout before the work item is queued\n @return 0 if success, negative error code otherwise"]
    pub fn k_work_delayable_schedule(
        workqueue: *mut k_workqueue,
        dwork: *mut k_work_delayable,
        timeout: k_timeout_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Schedule a delayable work item for the system workqueue.\n\n @see k_work_delayable_schedule\n\n @param dwork\n @param timeout\n @return __kernel"]
    pub fn k_system_work_delayable_schedule(
        dwork: *mut k_work_delayable,
        timeout: k_timeout_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Cancel a delayable work item which has been scheduled but not already\n queued for processing.\n\n If the work item is not yet scheduled, the function returns -EAGAIN.\n - If the work item is scheduled, the submission is cancelled and the function\n returns 0.\n - If the work item not schedule but still in the queue for processing, the\n function returns -EBUSY.\n - If the work item is not schedule and not in the queue for processing, the\n function returns -EAGAIN.\n\n @param dwork\n @return 0 if success, negative error code otherwise"]
    pub fn k_work_delayable_cancel(dwork: *mut k_work_delayable) -> i8;
}
#[doc = " @brief Structure representing a mutex, \"lock\" parameter tells\n if the current is locked or not (0 if lock, 0xFF otherwise).\n\n Waitqueue list contains all threads pending for the mutex,\n first thread to wake up when mutex is unlocked is first in the queue."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mutex {
    pub lock: u8,
    pub waitqueue: dnode,
    pub owner: *mut k_thread,
}
extern "C" {
    #[doc = " @brief Initialize a mutex\n\n @param mutex address of the mutex structure"]
    pub fn k_mutex_init(mutex: *mut k_mutex) -> i8;
}
extern "C" {
    #[doc = " @brief Lock a mutex, return immediately if mutex is available,\n otherwise wait until the mutex is unlocked or timeout.\n\n If the mutex is available, the scheduler is minot called.\n\n If the mutex ic locked, the current thread is unscheduled and\n added to the pending queue (\"waitqueue\") of the mutex,\n it will be woke up when the thread reach the top of this\n waitqueue and the mutex is available again.\n\n If timeout is different from K_FOREVER,\n the thread will be woke up when the timeout expires, in this case\n the function will check again for the mutex availability.\n (current thread is removed from the pending queue).\n\n Don't lock a mutex from an interrupt routine !\n\n If timeout is K_NO_WAIT, this function returns immediately.\n\n @param mutex address of the mutex structure\n @param timeout time pending the mutex (K_NO_WAIT, K_MSEC(1000), K_FOREVER)\n @return uint8_t 0 if mutex locked any other value otherwise"]
    pub fn k_mutex_lock(mutex: *mut k_mutex, timeout: k_timeout_t) -> i8;
}
extern "C" {
    #[doc = " @brief Unlock a mutex, wake up the first pending thread if the pending queue\n is not empty.\n\n Switch thread before returning if a thread is pending on the mutex.\n\n This function doesn't check if the current thread\n actually own the mutex. This function sets interrupt flag when returning.\n\n Don't unlock a mutex from an interrupt routine !\n\n @param mutex : address of the mutex structure"]
    pub fn k_mutex_unlock(mutex: *mut k_mutex) -> *mut k_thread;
}
extern "C" {
    pub fn k_mutex_cancel_wait(mutex: *mut k_mutex) -> i8;
}
extern "C" {
    #[doc = " @brief Arch lock a mutex, doesn't clear the interrupt flag (if set)\n and set it to its original state when finished.\n\n @param mutex address of the mutex structure\n @return uint8_t 0 if mutex locked any other value otherwise"]
    pub fn z_mutex_lock(mutex: *mut k_mutex) -> u8;
}
extern "C" {
    #[doc = " @brief Arch unlock a mutex, don't need the interrupt flag to be disabled\n\n @param mutex"]
    pub fn z_mutex_unlock(mutex: *mut k_mutex) -> *mut k_thread;
}
#[doc = " @brief Structure describing a semaphore, \"count\" parameter tells the number\n of available semaphore, \"limit\" describe the maximum number of semaphores.\n\n Waitqueue list contains all threads pending for the semaphore,\n first thread to wake up when a semaphore is available is at the\n first element of the queue."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_sem {
    pub count: u8,
    pub limit: u8,
    pub waitqueue: dnode,
}
extern "C" {
    #[doc = " @brief Initialize a semaphore\n\n @param sem : structure representing the semaphore"]
    pub fn k_sem_init(sem: *mut k_sem, initial_count: u8, limit: u8) -> i8;
}
extern "C" {
    #[doc = " @brief Take a semaphore, return immediately if a semaphore is available,\n otherwise wait until a semaphore is given or timeout.\n\n If a semaphore is available, the scheduler is not called.\n\n If no semaphore is available, the current thread is unscheduled and added\n to the pending queue (\"waitqueue\") of the semaphore,  it will be woke up\n when the thread reach the top of this waitqueue and a semaphore is available.\n\n If timeout is different from K_FOREVER, the thread will be woke up\n when the timeout expires, in this case the function will check\n again for a semaphore availability.\n (current thread is removed from the pending queue).\n\n Cannot be called from an interrupt routine\n if timeout is different from K_NO_WAIT.\n\n @param sem address of the semaphore structure\n @param timeout time waiting the semaphore (e.g. K_NO_WAIT, K_MSEC(1000),\n K_FOREVER)\n @return uint8_t 0 if a semaphore is taken any other value otherwise"]
    pub fn k_sem_take(sem: *mut k_sem, timeout: k_timeout_t) -> i8;
}
extern "C" {
    #[doc = " @brief Give a semaphore, wake up the first pending thread if the pending\n queue is not empty.\n\n Switch thread before returning if a thread is pending on a semaphore.\n\n This function sets interrupt flag when returning.\n\n Give a semaphore if the \"limit\" is reached will have no effect.\n\n Can be called from an interrupt routine.\n\n @param sem : address of the semaphore structure\n\n @return thread that was woken up, NULL otherwise"]
    pub fn k_sem_give(sem: *mut k_sem) -> *mut k_thread;
}
#[doc = " @brief Timer handler function prototype\n\n @param timer Timer instance\n\n @return int 0 to keep the timer running, non-zero to stop it\n\n @warning Never call any k_yield(), k_yield_from_isr(),\n k_yield_from_isr_cond() from a timer handler.\n"]
pub type k_timer_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut k_timer) -> ::core::ffi::c_int>;
#[doc = " @brief Requires additionnal stack (IDLE thread for example)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_timer {
    pub tie: titem,
    pub timeout: k_timeout_t,
    pub handler: k_timer_handler_t,
}
extern "C" {
    pub fn z_timer_init_module();
}
extern "C" {
    pub fn z_timers_process();
}
extern "C" {
    pub fn z_timer_start(timer: *mut k_timer, starting_delay: k_timeout_t);
}
extern "C" {
    pub fn k_timer_init(
        timer: *mut k_timer,
        handler: k_timer_handler_t,
        timeout: k_timeout_t,
        starting_delay: k_timeout_t,
    ) -> i8;
}
extern "C" {
    pub fn k_timer_started(timer: *mut k_timer) -> bool;
}
extern "C" {
    #[doc = " @brief Stop a timer\n\n Note: Usage of this function is discouraged in timer handlers.\n Prefer returning any non-zero value from the handler to stop the timer.\n\n @param timer\n @return __kernel"]
    pub fn k_timer_stop(timer: *mut k_timer) -> i8;
}
extern "C" {
    pub fn k_timer_start(timer: *mut k_timer, starting_delay: k_timeout_t) -> i8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_signal {
    pub signal: u8,
    pub flags: u8,
    pub waitqueue: dnode,
}
extern "C" {
    #[doc = " @brief Initialize a signal object.\n\n @param sig"]
    pub fn k_signal_init(sig: *mut k_signal) -> i8;
}
extern "C" {
    #[doc = " @brief Wake up the first thread (TODO all threads) polling on the signal.\n\n @param sig\n @param value\n @return The thread that was woken up, NULL otherwise."]
    pub fn k_signal_raise(sig: *mut k_signal, value: u8) -> *mut k_thread;
}
extern "C" {
    #[doc = " @brief Poll on a signal.\n\n Signal must be cleared manually with K_SIGNAL_SET_UNREADY.\n\n TODO: Return the signal value that made the thread ready.\n\n @param sig\n @param timeout\n @return 0 on success, negative error code otherwise."]
    pub fn k_poll_signal(sig: *mut k_signal, timeout: k_timeout_t) -> i8;
}
extern "C" {
    #[doc = " @brief Cancel the wait of all threads polling on the signal.\n\n @param sig\n @return Number of threads that were woken up."]
    pub fn k_poll_cancel_wait(sig: *mut k_signal) -> u8;
}
#[doc = " @brief Structure representing a memory slab.\n\n buffer : buffer from which all blocks will be allocated.\n count : numbers of blocks\n block_size : _block_size of a block\n free_list : list of all free blocks\n waitqueue : list contains all threads pending on a fifo item.\n\n Note : sizeof(buffer) must equals count * block_size"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_mem_slab {
    pub buffer: *mut ::core::ffi::c_void,
    pub count: u8,
    pub block_size: u16,
    pub free_list: *mut snode,
    pub waitqueue: dnode,
}
extern "C" {
    #[doc = " @brief This function is called on start up to initialize all memory\n slabs defined at runtime using the macro K_MEM_SLAB_DEFINE"]
    pub fn z_mem_slab_init_module();
}
extern "C" {
    #[doc = " @brief Initialize a memory slab at runtime\n\n @param slab address of the slab structure\n @param buffer address of the buffer\n @param block_size\n @param blocks_count\n @return return 0 on success else error code"]
    pub fn k_mem_slab_init(
        slab: *mut k_mem_slab,
        buffer: *mut ::core::ffi::c_void,
        block_size: size_t,
        blocks_count: u8,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Finalize the initialization of a memory slab when declared using\n K_MEM_SLAB_DEFINE and CONFIG_AVRTOS_LINKER_SCRIPT is disabled.\n\n @param slab"]
    pub fn z_mem_slab_finalize_init(slab: *mut k_mem_slab);
}
extern "C" {
    #[doc = " @brief Allocate a memory block.\n\n If there is no block available timeout is different from K_NO_WAIT,\n the function is blocking until a block is freed or timeout.\n\n Can be called from an interrupt routine with timeout equals to K_NO_WAIT.\n\n Assumptions :\n - slab not null\n - mem not null\n\n @param slab\n @param mem\n @param timeout\n @return 0 on success else error code\n - ENOMEM : no block available\n - ETIMEDOUT : timeout expired\n - EINTR : interrupted by a signal\n - ECANCELED : wait aborted"]
    pub fn k_mem_slab_alloc(
        slab: *mut k_mem_slab,
        mem: *mut *mut ::core::ffi::c_void,
        timeout: k_timeout_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Free a memory block and notify the first pending thread that\n a mem slab is available.\n\n Switch thread before returning if a thread is pending on a block.\n\n Can be called from an interrupt routine.\n\n Assumptions :\n - slab not null\n - mem not null\n - mem is currently \"allocated\"\n\n @param slab\n @param mem\n @return The thread that was woken up or NULL if no thread was woken up."]
    pub fn k_mem_slab_free(slab: *mut k_mem_slab, mem: *mut ::core::ffi::c_void) -> *mut k_thread;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_msgq {
    pub waitqueue: dnode,
    pub msg_size: size_t,
    pub max_msgs: u8,
    pub used_msgs: u8,
    pub buf_start: *mut ::core::ffi::c_void,
    pub buf_end: *mut ::core::ffi::c_void,
    pub read_cursor: *mut ::core::ffi::c_void,
    pub write_cursor: *mut ::core::ffi::c_void,
}
extern "C" {
    #[doc = " @brief Initialize a MsgQ\n\n @param msgq\n @param buffer\n @param msg_size\n @param max_msgs"]
    pub fn k_msgq_init(
        msgq: *mut k_msgq,
        buffer: *mut ::core::ffi::c_char,
        msg_size: size_t,
        max_msgs: u32,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Try to append the message @a data to the MsgQ @a msgq.\n\n Try until timeout.\n\n Don't call from an ISR with timeout != K_NO_WAIT.\n\n @param msgq\n @param data\n @param timeout\n @return 0 on success (ETIMEDOUT on timeout, ECANCELED on canceled\n      ENOMEM on MsgQ full)"]
    pub fn k_msgq_put(
        msgq: *mut k_msgq,
        data: *const ::core::ffi::c_void,
        timeout: k_timeout_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Try to get a message @a data to the MsgQ @a msgq.\n\n  Try until timeout.\n\n Don't call from an ISR with timeout != K_NO_WAIT.\n\n @param msgq\n @param data\n @param timeout\n @return 0 on success (ETIMEDOUT on timeout, ECANCELED on canceled\n      ENOMSG on no message)"]
    pub fn k_msgq_get(
        msgq: *mut k_msgq,
        data: *mut ::core::ffi::c_void,
        timeout: k_timeout_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Cancel all thread pending on the MsgQ (reading or writing).\n And reset the MsgQ state\n\n @param msgq\n @return Number of canceled threads"]
    pub fn k_msgq_purge(msgq: *mut k_msgq) -> u8;
}
extern "C" {
    #[doc = " @brief Peek the first message of the MsgQ without removing it.\n\n @param msgq\n @param data\n @return 0 on success (ENOMSG on no message)"]
    pub fn k_msgq_peek(msgq: *mut k_msgq, data: *mut ::core::ffi::c_void) -> i8;
}
extern "C" {
    #[doc = " @brief Get number of free messages in the MsgQ\n\n @param msgq\n @return Number of free messages in the MsgQ"]
    pub fn k_msgq_num_free_get(msgq: *mut k_msgq) -> u8;
}
extern "C" {
    #[doc = " @brief Get the number of used messages in the MsgQ\n\n @param msgq\n @return Number of used messages in the MsgQ"]
    pub fn k_msgq_num_used_get(msgq: *mut k_msgq) -> u8;
}
extern "C" {
    pub fn k_set_stdio_usart0();
}
extern "C" {
    pub fn k_sleep_1s();
}
extern "C" {
    pub fn z_rust_irq_lock() -> u8;
}
extern "C" {
    pub fn z_rust_irq_unlock(key: u8);
}
extern "C" {
    pub fn z_rust_sys(sys: u16) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTI_Ctrl_Device {
    pub EICRn: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCI_Ctrl_Device {
    pub PCMSK: [u8; 3usize],
}
extern "C" {
    #[doc = " @brief Configure an external interrupt\n\n @param exti EXTI number\n @param isc\n @return int8_t 0 on success, -EINVAL if EXTI number is invalid\n\n Example for ATmega328P :\n\n ```c\n #include <avr/io.h>\n #include <avrtos/drivers/exti.h>\n exti_configure(INT0, ISC_FALLING);\n exti_clear_flag(INT0);\n exti_enable(INT0);\n ```"]
    pub fn exti_configure(exti: u8, isc: u8) -> i8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_Device {
    pub PIN: u8,
    pub DDR: u8,
    pub PORT: u8,
}
extern "C" {
    pub fn gpio_init(gpio: *mut GPIO_Device, dir_mask: u8, pullup_mask: u8);
}
extern "C" {
    pub fn gpio_pin_init(gpio: *mut GPIO_Device, pin: u8, dir: u8, pullup: u8);
}
extern "C" {
    pub fn gpio_pin_set_direction(gpio: *mut GPIO_Device, pin: u8, direction: u8);
}
extern "C" {
    pub fn gpio_pin_set_pullup(gpio: *mut GPIO_Device, pin: u8, pullup: u8);
}
extern "C" {
    pub fn gpio_pin_write_state(gpio: *mut GPIO_Device, pin: u8, state: u8);
}
extern "C" {
    pub fn gpio_pin_toggle(gpio: *mut GPIO_Device, pin: u8);
}
extern "C" {
    pub fn gpio_pin_read_state(gpio: *mut GPIO_Device, pin: u8) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_Device {
    pub TWBRn: u8,
    pub TWSRn: u8,
    pub TWARn: u8,
    pub TWDRn: u8,
    pub TWCRn: u8,
    pub TWAMRn: u8,
}
pub mod i2c_prescaler_t {
    pub type Type = ::core::ffi::c_uint;
    pub const I2C_PRESCALER_1: Type = 0;
    pub const I2C_PRESCALER_4: Type = 1;
    pub const I2C_PRESCALER_16: Type = 2;
    pub const I2C_PRESCALER_64: Type = 3;
}
#[doc = " @brief Configuration structure for I2C"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub twbr: u8,
}
impl i2c_config {
    #[inline]
    pub fn prescaler(&self) -> i2c_prescaler_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_prescaler(&mut self, val: i2c_prescaler_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prescaler: i2c_prescaler_t::Type) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let prescaler: u16 = unsafe { ::core::mem::transmute(prescaler) };
            prescaler as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod i2c_error {
    #[doc = " @brief I2C driver error codes"]
    pub type Type = ::core::ffi::c_uint;
    pub const I2C_ERROR_NONE: Type = 0;
    pub const I2C_ERROR_BUS: Type = 1;
    pub const I2C_ERROR_ADDR: Type = 2;
    pub const I2C_ERROR_DATA: Type = 3;
    pub const I2C_ERROR_ARGS: Type = 4;
}
#[doc = " @brief I2C driver error codes"]
pub use self::i2c_error::Type as i2c_error_t;
extern "C" {
    #[doc = " @brief Initialize I2C driver\n\n @param dev Device to initialize\n @param config Configuration structure\n @return int8_t 0 if success, negative value otherwise"]
    pub fn i2c_init(dev: *mut I2C_Device, config: i2c_config) -> i8;
}
extern "C" {
    #[doc = " @brief Deinitialize I2C driver\n\n @param dev Device to deinitialize\n @return int8_t 0 if success, negative value otherwise"]
    pub fn i2c_deinit(dev: *mut I2C_Device) -> i8;
}
extern "C" {
    #[doc = " @brief Transmit data to I2C device as master\n\n The given buffer must remain valid until the transmission is complete.\n\n If CONFIG_I2C_BLOCKING option is enabled, this function will block until\n the reception is complete, otherwise it will return immediately and the\n user must poll for the end of transmission using i2c_poll_end().\n\n @param dev I2C device\n @param addr Device address\n @param data Data buffer to transmit\n @param len Buffer length\n @return int8_t Number of bytes written if success, negative value otherwise"]
    pub fn i2c_master_write(dev: *mut I2C_Device, addr: u8, data: *const u8, len: u8) -> i8;
}
extern "C" {
    #[doc = " @brief Receive data from I2C device as master\n\n The given buffer must remain valid until the reception is complete.\n\n If CONFIG_I2C_BLOCKING option is enabled, this function will block until\n the reception is complete, otherwise it will return immediately and the\n user must poll for the end of transmission using i2c_poll_end().\n\n @param dev I2C device\n @param addr Device address\n @param data Data buffer to receive\n @param len Buffer length\n @return int8_t Number of bytes written if success, negative value otherwise"]
    pub fn i2c_master_read(dev: *mut I2C_Device, addr: u8, data: *mut u8, len: u8) -> i8;
}
extern "C" {
    #[doc = " @brief Write w_len bytes to I2C device then read r_len bytes from it as master.\n\n This function is convenient for devices that require a write operation before\n a read operation. It is equivalent to calling i2c_master_write() followed by\n i2c_master_read() but it is more efficient as it does not require to wait for\n the end of the first transmission before starting the second one.\n\n The given buffer must remain valid until the transmission is complete.\n\n If CONFIG_I2C_BLOCKING option is enabled, this function will block until\n the reception is complete, otherwise it will return immediately and the\n user must poll for the end of transmission using i2c_poll_end().\n\n @param dev I2C device\n @param addr Device address\n @param data Data buffer containing the wlen bytes to write, on function return\n \t\t\t\tit will contain the rlen bytes read. Its size must be at least\n \t\t\t\tthe maximum between wlen and rlen.\n @param wlen Number of bytes to write\n @param rlen Number of bytes to read\n @return int8_t Number of bytes written if success, negative value otherwise"]
    pub fn i2c_master_write_read(
        dev: *mut I2C_Device,
        addr: u8,
        data: *mut u8,
        wlen: u8,
        rlen: u8,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Get I2C status\n\n @param dev I2C device\n @return int8_t 0 if ready, -EBUSY if busy, negative value otherwise"]
    pub fn i2c_status(dev: *mut I2C_Device) -> i8;
}
extern "C" {
    #[doc = " @brief Poll for I2C end of transmission\n\n Should be used when CONFIG_I2C_BLOCKING option is disabled.\n\n @param dev I2C device\n @return i2c_error_t I2C_ERROR_NONE if success, negative value otherwise"]
    pub fn i2c_poll_end(dev: *mut I2C_Device) -> i2c_error_t;
}
extern "C" {
    #[doc = " @brief Retrieve last I2C error\n\n Should be used when CONFIG_I2C_LAST_ERROR option is enabled.\n\n @param dev\n @return i2c_error_t"]
    pub fn i2c_last_error(dev: *mut I2C_Device) -> i2c_error_t;
}
extern "C" {
    #[doc = " @brief Calculate I2C configuration structure from desired frequency\n\n @param config Structure to fill\n @param desired_freq Desired frequency\n @return int8_t 0 if success, negative value otherwise"]
    pub fn i2c_calc_config(config: *mut i2c_config, desired_freq: u32) -> i8;
}
#[doc = " @brief SPI device registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_Device {
    pub SPCRn: u8,
    pub SPSRn: u8,
    pub SPDRn: u8,
}
pub mod spi_prescaler_t {
    pub type Type = ::core::ffi::c_uint;
    pub const SPI_PRESCALER_4: Type = 0;
    pub const SPI_PRESCALER_16: Type = 1;
    pub const SPI_PRESCALER_64: Type = 2;
    pub const SPI_PRESCALER_128: Type = 3;
    pub const SPI_PRESCALER_X2: Type = 4;
    pub const SPI_PRESCALER_X8: Type = 5;
    pub const SPI_PRESCALER_X32: Type = 6;
    pub const SPI_PRESCALER_X64: Type = 7;
}
pub mod spi_mode_t {
    pub type Type = ::core::ffi::c_uint;
    pub const SPI_MODE_MASTER: Type = 0;
    pub const SPI_MODE_SLAVE: Type = 1;
}
pub mod spi_clock_polarity_t {
    pub type Type = ::core::ffi::c_uint;
    pub const SPI_CLOCK_POLARITY_RISING: Type = 0;
    pub const SPI_CLOCK_POLARITY_FALLING: Type = 1;
}
pub mod spi_clock_phase_t {
    pub type Type = ::core::ffi::c_uint;
    pub const SPI_CLOCK_PHASE_SAMPLE: Type = 0;
    pub const SPI_CLOCK_PHASE_SETUP: Type = 1;
}
#[doc = " SPI configuration (1 byte)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spi_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl spi_config {
    #[inline]
    pub fn mode(&self) -> spi_mode_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: spi_mode_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> spi_clock_polarity_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: spi_clock_polarity_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn phase(&self) -> spi_clock_phase_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_phase(&mut self, val: spi_clock_phase_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_enabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_irq_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prescaler(&self) -> spi_prescaler_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_prescaler(&mut self, val: spi_prescaler_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: spi_mode_t::Type,
        polarity: spi_clock_polarity_t::Type,
        phase: spi_clock_phase_t::Type,
        irq_enabled: u8,
        prescaler: spi_prescaler_t::Type,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mode: u16 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let polarity: u16 = unsafe { ::core::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let phase: u16 = unsafe { ::core::mem::transmute(phase) };
            phase as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let irq_enabled: u8 = unsafe { ::core::mem::transmute(irq_enabled) };
            irq_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let prescaler: u16 = unsafe { ::core::mem::transmute(prescaler) };
            prescaler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " SPI registers (2 bytes)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_regs {
    pub spcr: u8,
    pub spsr: u8,
}
extern "C" {
    #[doc = " @brief Initialize SPI peripheral.\n\n @param config Configuration to use.\n @return int8_t 0 on success, negative on error."]
    pub fn spi_init(config: spi_config) -> i8;
}
extern "C" {
    #[doc = " @brief Build SPI regs from init configuration.\n\n @param config\n @return struct spi_regs"]
    pub fn spi_config_into_regs(config: spi_config) -> spi_regs;
}
extern "C" {
    #[doc = " @brief Apply SPI regs.\n\n @param regs"]
    pub fn spi_regs_restore(regs: *const spi_regs);
}
extern "C" {
    #[doc = " @brief Swap SPI regs.\n\n @param regs"]
    pub fn spi_regs_swap(regs: *mut spi_regs);
}
extern "C" {
    #[doc = " @brief Retrieve SPI regs.\n\n @param regs"]
    pub fn spi_regs_save(regs: *mut spi_regs);
}
extern "C" {
    #[doc = " @brief Deinitialize SPI peripheral."]
    pub fn spi_deinit();
}
extern "C" {
    #[doc = " @brief Transceive a byte over SPI.\n\n Assume that the slave is selected.\n\n @param tx\n @return char"]
    pub fn spi_transceive(tx: ::core::ffi::c_char) -> ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Transceive a buffer over SPI.\n\n Assume that the slave is selected.\n\n @param rxtx\n @param len"]
    pub fn spi_transceive_buf(rxtx: *mut ::core::ffi::c_char, len: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_slave {
    pub cs_port: *mut GPIO_Device,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub regs: spi_regs,
}
impl spi_slave {
    #[inline]
    pub fn cs_pin(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_cs_pin(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn active_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cs_pin: u8, active_state: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let cs_pin: u8 = unsafe { ::core::mem::transmute(cs_pin) };
            cs_pin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let active_state: u8 = unsafe { ::core::mem::transmute(active_state) };
            active_state as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " @brief Initialize a SPI slave structure\n\n @param slave Pointer to the slave structure.\n @param cs_port Pointer to the GPIO port of the slave chip select pin.\n @param cs_pin Slave chip select pin.\n @param active_state Slave chip select active low.\n @param regs SPI regs to use for the slave.\n @return int8_t 0 on success, negative on error."]
    pub fn spi_slave_init(
        slave: *mut spi_slave,
        cs_port: *mut GPIO_Device,
        cs_pin: u8,
        active_state: u8,
        regs: *const spi_regs,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Initialize a SPI chip select pin for the slave.\n\n @param slave Pointer to the slave structure.\n @return int8_t 0 on success, negative on error."]
    pub fn spi_slave_ss_init(slave: *const spi_slave) -> i8;
}
extern "C" {
    #[doc = " @brief Transceive a byte over SPI with a slave.\n\n The slave is selected before the transmission and deselected after.\n\n @param slave\n @param tx\n @return char"]
    pub fn spi_slave_transceive(
        slave: *const spi_slave,
        tx: ::core::ffi::c_char,
    ) -> ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @brief Transceive a buffer over SPI with a slave.\n\n The slave is selected before the transmission and deselected after.\n\n @param slave\n @param rxtx\n @param len"]
    pub fn spi_slave_transceive_buf(
        slave: *const spi_slave,
        rxtx: *mut ::core::ffi::c_char,
        len: u8,
    );
}
#[doc = " @brief SPI callback function type for asynchronous SPI tranceive.\n\n @param rxtx Pointer to the byte to transmit. The received byte is also\n returned in this pointer. If NULL, we are notified that the asynchronous\n transmission has been canceled.\n @return true Continue the transmission, false stop the transmission."]
pub type spi_callback_t =
    ::core::option::Option<unsafe extern "C" fn(rxtx: *mut ::core::ffi::c_char) -> bool>;
extern "C" {
    #[doc = " @brief Transceive a byte over SPI asynchronously in master and slave mode.\n\n Assume that the slave is selected beforce the transmission and deselected\n after (or deselected on the callback function).\n\n This function is non-blocking and returns immediately.\n\n The function enables the SPI interrupt and disables it when the transmission\n is complete.\n\n In master mode, the transmission is started immediately. When a byte\n transmission is complete, the callback function is called in the interrupt\n context. The received byte is passed as an argument to the callback function.\n The next byte to transmit is returned by the callback using the argument\n pointer. If the callback returns true, the transmission is continued,\n otherwise it is stopped.\n\n If it is decided to abort the asynchronous transmission, the byte prepared\n for transmission in the callback is ignored.\n\n In slave mode, the behavior stays the same, except that the transmission is\n started when the master starts to transmit. The callback function is called\n each time a byte is received from the master.\n\n In slave mode:\n In case you want to cancel a transmission, call spi_cancel_async().\n\n @param first_tx First byte to transmit.\n @param callback Callback function to call when the transmission of the first\n byte is complete.\n @return int8_t number of bytes sent on success, negative value on error."]
    pub fn spi_transceive_async_start(
        first_tx: ::core::ffi::c_char,
        callback: spi_callback_t,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Check if an asynchronous SPI transmission is running.\n\n As synchronous functions should not be called while an asynchronous\n transmission is running, this function can be used for this purpose.\n\n @return true\n @return false"]
    pub fn spi_async_inprogress() -> bool;
}
extern "C" {
    #[doc = " @brief Cancel an asynchronous SPI transmission.\n\n @return int"]
    pub fn spi_cancel_async() -> i8;
}
#[doc = " @brief 16 bits timers registers structure\n - Timer 1, 3, 4, 5 on ATmega2560\n - Timer 1 on ATmega328p"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TIMER16_Device {
    pub TCCRnA: u8,
    pub TCCRnB: u8,
    pub TCCRnC: u8,
    pub _reserved1: u8,
    pub __bindgen_anon_1: TIMER16_Device__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TIMER16_Device__bindgen_ty_1 {
    pub __bindgen_anon_1: TIMER16_Device__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: TIMER16_Device__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIMER16_Device__bindgen_ty_1__bindgen_ty_1 {
    pub TCNTnL: u8,
    pub TCNTnH: u8,
    pub ICRnL: u8,
    pub ICRnH: u8,
    pub OCRnAL: u8,
    pub OCRnAH: u8,
    pub OCRnBL: u8,
    pub OCRnBH: u8,
    pub OCRnCL: u8,
    pub OCRnCH: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TIMER16_Device__bindgen_ty_1__bindgen_ty_2 {
    pub TCNTn: u16,
    pub IRCN: u16,
    pub __bindgen_anon_1: TIMER16_Device__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TIMER16_Device__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: TIMER16_Device__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub OCRnx: [u16; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIMER16_Device__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub OCRnA: u16,
    pub OCRnB: u16,
    pub OCRnC: u16,
}
#[doc = " @brief 8 bits timer registers structure\n - Timer 1 and 2 on ATmega328p and ATmega2560"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIMER8_Device {
    pub TCCRnA: u8,
    pub TCCRnB: u8,
    pub TCNTn: u8,
    pub OCRnA: u8,
    pub OCRnB: u8,
}
pub mod timer_mode_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER_MODE_NORMAL: Type = 0;
    pub const TIMER_MODE_PWM_PC_8bit: Type = 1;
    pub const TIMER_MODE_PWM_PC_9bit: Type = 2;
    pub const TIMER_MODE_PWM_PC_10bit: Type = 3;
    pub const TIMER_MODE_CTC: Type = 4;
    pub const TIMER_MODE_FAST_PWM_8bit: Type = 5;
    pub const TIMER_MODE_FAST_PWM_9bit: Type = 6;
    pub const TIMER_MODE_FAST_PWM_10bit: Type = 7;
    pub const TIMER_MODE_PWM_PHASE_FREQUENCY_CORRECT_ICRn: Type = 8;
    pub const TIMER_MODE_PWM_PHASE_FREQUENCY_CORRECT_OCRnA: Type = 9;
    pub const TIMER_MODE_PWM_PHASE_CORRECT_ICRn: Type = 10;
    pub const TIMER_MODE_PWM_PHASE_CORRECT_OCRnA: Type = 11;
    pub const TIMER_MODE_CTC_ICRn: Type = 12;
    pub const TIMER_MODE_RESERVED: Type = 13;
    pub const TIMER_MODE_FAST_PWM_ICR1: Type = 14;
    pub const TIMER_MODE_FAST_PWM_OCR1A: Type = 15;
}
pub mod timer2_prescaler_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER2_STOPPED: Type = 0;
    pub const TIMER2_PRESCALER_1: Type = 1;
    pub const TIMER2_PRESCALER_8: Type = 2;
    pub const TIMER2_PRESCALER_32: Type = 3;
    pub const TIMER2_PRESCALER_64: Type = 4;
    pub const TIMER2_PRESCALER_128: Type = 5;
    pub const TIMER2_PRESCALER_256: Type = 6;
    pub const TIMER2_PRESCALER_1024: Type = 7;
}
pub mod timer_prescaler_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER_STOPPED: Type = 0;
    pub const TIMER_PRESCALER_1: Type = 1;
    pub const TIMER_PRESCALER_8: Type = 2;
    pub const TIMER_PRESCALER_64: Type = 3;
    pub const TIMER_PRESCALER_256: Type = 4;
    pub const TIMER_PRESCALER_1024: Type = 5;
    pub const TIMER_EXT_FALLING: Type = 6;
    pub const TIMER_EXT_RISING: Type = 7;
}
pub mod timer16_interrupt_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER16_OVERFLOW_INTERRUPT: Type = 0;
    pub const TIMER16_OUTPUT_COMPARE_MATCH_A_INTERRUPT: Type = 1;
    pub const TIMER16_OUTPUT_COMPARE_MATCH_B_INTERRUPT: Type = 2;
    pub const TIMER16_OUTPUT_COMPARE_MATCH_C_INTERRUPT: Type = 3;
    pub const TIMER16_INPUT_CAPTURE_INTERRUPT: Type = 5;
}
pub mod timer_channel_com_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER_CHANNEL_COMP_MODE_NORMAL: Type = 0;
    pub const TIMER_CHANNEL_COMP_MODE_TOGGLE: Type = 1;
    pub const TIMER_CHANNEL_COMP_MODE_CLEAR: Type = 2;
    pub const TIMER_CHANNEL_COMP_MODE_SET: Type = 3;
}
pub mod timer_channel_t {
    pub type Type = ::core::ffi::c_uint;
    pub const TIMER_CHANNEL_A: Type = 0;
    pub const TIMER_CHANNEL_B: Type = 1;
    pub const TIMER_CHANNEL_C: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_channel_compare_config {
    pub mode: timer_channel_com_t::Type,
    pub value: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timer_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " @brief Timer counter value\n\n Note: Cast to uint8_t for 8 bits timers"]
    pub counter: u16,
    #[doc = " @brief Enable interrupts handlers"]
    pub timsk: u8,
}
impl timer_config {
    #[inline]
    pub fn mode(&self) -> timer_mode_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: timer_mode_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn prescaler(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prescaler(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: timer_mode_t::Type,
        prescaler: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let mode: u16 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let prescaler: u8 = unsafe { ::core::mem::transmute(prescaler) };
            prescaler as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ll_timer8_init(dev: *mut TIMER8_Device, tim_idx: u8, config: *const timer_config);
}
extern "C" {
    pub fn ll_timer16_init(dev: *mut TIMER16_Device, tim_idx: u8, config: *const timer_config);
}
extern "C" {
    pub fn ll_timer16_channel_configure(
        dev: *mut TIMER16_Device,
        channel: timer_channel_t::Type,
        config: *const timer_channel_compare_config,
    );
}
extern "C" {
    pub fn ll_timer8_deinit(dev: *mut TIMER8_Device, tim_idx: u8);
}
extern "C" {
    pub fn ll_timer16_deinit(dev: *mut TIMER16_Device, tim_idx: u8);
}
extern "C" {
    pub fn timer_calc_prescaler(timer_index: u8, period_us: u32, counter: *mut u16) -> i8;
}
extern "C" {
    pub fn timer8_init(dev: *mut TIMER8_Device, config: *const timer_config) -> i8;
}
extern "C" {
    pub fn timer16_init(dev: *mut TIMER16_Device, config: *const timer_config) -> i8;
}
extern "C" {
    pub fn timer8_deinit(dev: *mut TIMER8_Device) -> i8;
}
extern "C" {
    pub fn timer16_deinit(dev: *mut TIMER16_Device) -> i8;
}
pub type timer_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut ::core::ffi::c_void,
        tim_idx: u8,
        user_data: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    pub fn timer_init(
        tim_idx: u8,
        period_us: u32,
        cb: timer_callback_t,
        user_data: *mut ::core::ffi::c_void,
        flags: u8,
    ) -> i8;
}
extern "C" {
    pub fn timer_start(tim_idx: u8);
}
extern "C" {
    pub fn timer_stop(tim_idx: u8);
}
extern "C" {
    pub fn timer_get_prescaler(tim_idx: u8) -> u8;
}
extern "C" {
    pub fn timer_get_max_period_us(tim_idx: u8) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_Device {
    pub UCSRnA: u8,
    pub UCSRnB: u8,
    pub UCSRnC: u8,
    pub _reserved1: u8,
    pub UBRRnL: u8,
    pub UBRRnH: u8,
    pub UDRn: u8,
    pub _reserved2: u8,
}
pub mod usart_mode_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_MODE_ASYNCHRONOUS: Type = 0;
    pub const USART_MODE_SYNCHRONOUS: Type = 1;
    pub const USART_MODE_MSPI: Type = 2;
}
pub mod usart_parity_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_PARITY_NONE: Type = 0;
    pub const USART_PARITY_EVEN: Type = 2;
    pub const USART_PARITY_ODD: Type = 3;
}
pub mod usart_stop_bits_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_STOP_BITS_1: Type = 0;
    pub const USART_STOP_BITS_2: Type = 1;
}
pub mod usart_data_bits_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_DATA_BITS_5: Type = 0;
    pub const USART_DATA_BITS_6: Type = 1;
    pub const USART_DATA_BITS_7: Type = 2;
    pub const USART_DATA_BITS_8: Type = 3;
    pub const USART_DATA_BITS_9: Type = 7;
}
pub mod usart_speed_mode_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_SPEED_MODE_NORMAL: Type = 0;
    pub const USART_SPEED_MODE_DOUBLE: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usart_config {
    pub baudrate: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl usart_config {
    #[inline]
    pub fn receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transmitter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_transmitter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> usart_mode_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: usart_mode_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn parity(&self) -> usart_parity_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: usart_parity_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stopbits(&self) -> usart_stop_bits_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_stopbits(&mut self, val: usart_stop_bits_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn databits(&self) -> usart_data_bits_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_databits(&mut self, val: usart_data_bits_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn speed_mode(&self) -> usart_speed_mode_t::Type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_speed_mode(&mut self, val: usart_speed_mode_t::Type) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        receiver: u8,
        transmitter: u8,
        mode: usart_mode_t::Type,
        parity: usart_parity_t::Type,
        stopbits: usart_stop_bits_t::Type,
        databits: usart_data_bits_t::Type,
        speed_mode: usart_speed_mode_t::Type,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let receiver: u8 = unsafe { ::core::mem::transmute(receiver) };
            receiver as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transmitter: u8 = unsafe { ::core::mem::transmute(transmitter) };
            transmitter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let mode: u16 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let parity: u16 = unsafe { ::core::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let stopbits: u16 = unsafe { ::core::mem::transmute(stopbits) };
            stopbits as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let databits: u16 = unsafe { ::core::mem::transmute(databits) };
            databits as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let speed_mode: u16 = unsafe { ::core::mem::transmute(speed_mode) };
            speed_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ll_usart_init(dev: *mut UART_Device, config: *const usart_config);
}
extern "C" {
    pub fn usart_init(dev: *mut UART_Device, config: *const usart_config) -> i8;
}
extern "C" {
    pub fn usart_deinit(dev: *mut UART_Device) -> i8;
}
extern "C" {
    pub fn ll_usart_sync_putc(dev: *mut UART_Device, c: ::core::ffi::c_char);
}
extern "C" {
    pub fn ll_usart_sync_getc(dev: *mut UART_Device) -> u8;
}
extern "C" {
    pub fn usart_send(dev: *mut UART_Device, buf: *const ::core::ffi::c_char, len: size_t) -> i8;
}
pub mod usart_event_t {
    pub type Type = ::core::ffi::c_uint;
    pub const USART_EVENT_RX_COMPLETE: Type = 0;
    pub const USART_EVENT_TX_COMPLETE: Type = 1;
    pub const USART_EVENT_ERROR: Type = 2;
}
pub type usart_async_callback_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut UART_Device, ctx: *mut usart_async_context),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usart_async_context {
    pub evt: usart_event_t::Type,
    pub callback: usart_async_callback_t,
    pub rx: usart_async_context__bindgen_ty_1,
    pub tx: usart_async_context__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usart_async_context__bindgen_ty_1 {
    pub buf: *mut u8,
    pub size: size_t,
    pub cur: size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usart_async_context__bindgen_ty_2 {
    pub buf: *const u8,
    pub size: size_t,
    pub cur: size_t,
}
extern "C" {
    pub fn usart_set_callback(dev: *mut UART_Device, cb: usart_async_callback_t) -> i8;
}
extern "C" {
    pub fn usart_rx_disable(dev: *mut UART_Device) -> i8;
}
extern "C" {
    pub fn usart_rx_enable(
        dev: *mut UART_Device,
        buf: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> i8;
}
extern "C" {
    pub fn usart_tx(dev: *mut UART_Device, buf: *const ::core::ffi::c_void, size: size_t) -> i8;
}
#[doc = " @brief TCN75 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcn75_context {
    pub addr: u8,
    pub config: u8,
    pub i2c: *mut I2C_Device,
}
extern "C" {
    #[doc = " @brief Initialize a TCN75 context.\n\n @param tcn75 TCN75 context to initialize\n @param addr Address of the device\n @param config TCN75 configuration register\n @param i2c I2C device the TCN75 is connected to\n @return int8_t 0 if success, negative value otherwise"]
    pub fn tcn75_init_context(
        tcn75: *mut tcn75_context,
        addr_lsb: u8,
        config: u8,
        i2c: *mut I2C_Device,
    ) -> i8;
}
extern "C" {
    #[doc = " @brief Configure a TCN75 device using its configuration register.\n\n @param tcn75 initialized TCN75 context\n @return int8_t 0 if success, negative value otherwise"]
    pub fn tcn75_configure(tcn75: *mut tcn75_context) -> i8;
}
extern "C" {
    #[doc = " @brief Select the temperature register of a TCN75 device.\n\n @param tcn75 initialized TCN75 context\n @return int8_t 0 if success, negative value otherwise"]
    pub fn tcn75_select_data_register(tcn75: *mut tcn75_context) -> i8;
}
extern "C" {
    #[doc = " @brief Read the temperature from a TCN75 device.\n\n @param tcn75 initialized TCN75 context\n @return int16_t temperature in 0.01°C resolution, returns INT16_MAX if error"]
    pub fn tcn75_read(tcn75: *mut tcn75_context) -> i16;
}
extern "C" {
    #[doc = " @brief Select the temperature register of a TCN75 device and read the temperature.\n\n @param tcn75 initialized TCN75 context\n @return int16_t temperature in 0.01°C resolution, returns INT16_MAX if error"]
    pub fn tcn75_select_read(tcn75: *mut tcn75_context) -> i16;
}
extern "C" {
    #[doc = " @brief Init builtin LED"]
    pub fn led_init();
}
extern "C" {
    #[doc = " @brief Set builtin LED on"]
    pub fn led_on();
}
extern "C" {
    #[doc = " @brief Set builtin LED off"]
    pub fn led_off();
}
extern "C" {
    #[doc = " @brief Set builtin LED state"]
    pub fn led_set(state: u8);
}
extern "C" {
    #[doc = " @brief Toggle builtin LED"]
    pub fn led_toggle();
}
extern "C" {
    #[doc = " @brief Get builtin LED state"]
    pub fn led_get() -> u8;
}
